# 3D Secure Service

## Overview

The 3D Secure Service implements 3D Secure 2.0 authentication for card transactions. It provides both frictionless and challenge-based authentication flows, integrating with Access Control Servers (ACS) to verify cardholder identity.

## Features

- **3DS 2.0 Authentication**: Full support for 3D Secure 2.0 protocol
- **Frictionless Flow**: Risk-based authentication without cardholder interaction
- **Challenge Flow**: Browser redirect to ACS for cardholder authentication
- **CAVV/ECI/XID Generation**: Generates authentication values for PSP authorization
- **Redis State Management**: Stores transaction state with automatic expiration
- **gRPC API**: High-performance internal service communication
- **REST API**: Browser redirect callback handling

## Architecture

### Components

1. **ThreeDSService**: Core business logic for authentication flows
2. **ACSSimulator**: Simulates ACS for testing (replace with real ACS integration in production)
3. **ThreeDSecureGrpcService**: gRPC server for internal service calls
4. **ThreeDSController**: REST endpoints for browser redirects
5. **Redis**: Transaction state storage with TTL

### Authentication Flows

#### Frictionless Flow
```
1. Authorization Service → InitiateAuth (gRPC)
2. 3DS Service evaluates risk
3. If low risk: Generate CAVV/ECI/XID immediately
4. Return FRICTIONLESS status with auth data
5. Authorization Service proceeds to PSP
```

#### Challenge Flow
```
1. Authorization Service → InitiateAuth (gRPC)
2. 3DS Service evaluates risk
3. If high risk: Return CHALLENGE_REQUIRED with ACS URL
4. Browser redirects to ACS
5. Cardholder authenticates at ACS
6. ACS redirects back with PARes
7. CompleteAuth validates PARes
8. Generate CAVV/ECI/XID
9. Return AUTHENTICATED status
```

## API

### gRPC Service

```protobuf
service ThreeDSecureService {
  rpc InitiateAuth(ThreeDSRequest) returns (ThreeDSResponse);
  rpc CompleteAuth(ThreeDSCompleteRequest) returns (ThreeDSCompleteResponse);
  rpc ValidateAuth(ValidateAuthRequest) returns (ValidateAuthResponse);
}
```

### REST Endpoints

- `POST /api/v1/3ds/callback` - ACS callback handler
- `GET /api/v1/3ds/status/{transactionId}` - Check authentication status

## Configuration

### application.yml

```yaml
server:
  port: 8448

grpc:
  server:
    port: 9093

spring:
  redis:
    host: localhost
    port: 6379

threeds:
  acs:
    url: http://acs.example.com
  transaction:
    timeout-minutes: 10
```

### Environment Variables

- `REDIS_HOST`: Redis server hostname
- `REDIS_PORT`: Redis server port
- `ACS_URL`: Access Control Server URL

## Running the Service

### Prerequisites

- Java 17+
- Maven 3.8+
- Redis 6.0+

### Build

```bash
mvn clean install
```

### Run

```bash
mvn spring-boot:run
```

### Docker

```bash
docker build -t threeds-service .
docker run -p 8448:8448 -p 9093:9093 threeds-service
```

## Testing

### Run All Tests

```bash
mvn test
```

### Run Property Tests Only

```bash
mvn test -Dtest=*PropertyTest
```

### Run Unit Tests Only

```bash
mvn test -Dtest=*Test -Dtest=!*PropertyTest
```

## Authentication Data

### CAVV (Cardholder Authentication Verification Value)
- 20-byte Base64-encoded value
- Generated by ACS (simulated in this implementation)
- Proves authentication occurred

### ECI (Electronic Commerce Indicator)
- 2-digit code indicating authentication level
- `05`: Fully authenticated
- `06`: Attempted authentication
- `07`: No authentication

### XID (Transaction Identifier)
- 28-character Base64-encoded value
- Unique identifier for 3DS transaction
- Links authentication to authorization

## Integration

### From Authorization Service

```java
// Initiate 3DS authentication
ThreeDSRequest request = ThreeDSRequest.newBuilder()
    .setTransactionId(paymentId)
    .setMerchantId(merchantId)
    .setAmount(amount.toString())
    .setCurrency(currency)
    .setCardToken(cardToken)
    .setMerchantReturnUrl(returnUrl)
    .setBrowserInfo(browserInfo)
    .build();

ThreeDSResponse response = threeDSStub.initiateAuth(request);

if (response.getStatus() == ThreeDSStatus.FRICTIONLESS) {
    // Use CAVV/ECI/XID for PSP authorization
    String cavv = response.getCavv();
    String eci = response.getEci();
    String xid = response.getXid();
}
```

## Monitoring

### Metrics

- `threeds.authentication.initiated`: Counter of authentication initiations
- `threeds.authentication.completed`: Counter of completed authentications
- `threeds.authentication.failed`: Counter of failed authentications
- `threeds.authentication.timeout`: Counter of timed-out authentications

### Health Check

```bash
curl http://localhost:8448/actuator/health
```

## Security Considerations

1. **Transaction Expiration**: All transactions expire after 10 minutes
2. **PARes Validation**: Cryptographic validation of ACS responses (simulated)
3. **Redis Security**: Use password-protected Redis in production
4. **TLS**: Enable TLS for gRPC and REST endpoints in production
5. **ACS Integration**: Replace simulator with real ACS integration

## Requirements Validation

This service validates the following requirements:

- **5.1**: Redirects to ACS for challenge authentication
- **5.2**: Sends browser/device information for risk assessment
- **5.3**: Validates ACS authentication responses
- **5.4**: Includes CAVV/ECI/XID in authorization requests
- **5.5**: Handles authentication failures and timeouts

## Property-Based Testing

The service includes property-based tests that verify:

- **Property 12**: All authenticated transactions include CAVV, ECI, and XID
- Authentication data format and validity
- Frictionless vs challenge flow correctness
