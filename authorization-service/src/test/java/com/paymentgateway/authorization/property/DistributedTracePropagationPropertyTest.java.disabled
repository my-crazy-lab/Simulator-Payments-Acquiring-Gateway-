package com.paymentgateway.authorization.property;

import com.paymentgateway.authorization.dto.PaymentRequest;
import com.paymentgateway.authorization.dto.PaymentResponse;
import com.paymentgateway.authorization.service.PaymentService;
import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.SpanContext;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.context.Context;
import net.jqwik.api.*;
import net.jqwik.api.constraints.*;
import net.jqwik.spring.JqwikSpringSupport;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.math.BigDecimal;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Feature: payment-acquiring-gateway, Property 20: Distributed Trace Propagation
 * 
 * For any payment request, all service calls in the transaction flow should share 
 * the same trace ID in their span context.
 * 
 * Validates: Requirements 10.1, 10.2
 */
@JqwikSpringSupport
@SpringBootTest
@ActiveProfiles("test")
@Testcontainers
@org.junit.jupiter.api.Disabled("Requires Docker with PostgreSQL container")
class DistributedTracePropagationPropertyTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
        .withDatabaseName("payment_gateway_test")
        .withUsername("test")
        .withPassword("test");
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private Tracer tracer;
    
    @Property(tries = 100)
    void distributedTracePropagation(
            @ForAll @NumericChars @StringLength(value = 16) String cardNumber,
            @ForAll @IntRange(min = 1, max = 12) int expiryMonth,
            @ForAll @IntRange(min = 2025, max = 2035) int expiryYear,
            @ForAll @NumericChars @StringLength(value = 3) String cvv,
            @ForAll @BigRange(min = "0.01", max = "10000.00") BigDecimal amount) {
        
        // Arrange
        PaymentRequest request = new PaymentRequest(
            cardNumber, expiryMonth, expiryYear, cvv, amount, "USD"
        );
        UUID merchantId = UUID.randomUUID();
        
        // Create a parent span to simulate an incoming request with trace context
        Span parentSpan = tracer.spanBuilder("test-parent-span").startSpan();
        
        try (var scope = parentSpan.makeCurrent()) {
            // Get the trace ID from the parent span
            SpanContext parentContext = parentSpan.getSpanContext();
            String parentTraceId = parentContext.getTraceId();
            
            assertThat(parentTraceId)
                .as("Parent trace ID should be valid")
                .isNotNull()
                .isNotEmpty();
            
            // Act - Process payment within the trace context
            PaymentResponse response = paymentService.processPayment(request, merchantId);
            
            // Assert - Verify the trace context was propagated
            // Get the current span context
            Span currentSpan = Span.current();
            SpanContext currentContext = currentSpan.getSpanContext();
            String currentTraceId = currentContext.getTraceId();
            
            // The trace ID should be the same as the parent
            assertThat(currentTraceId)
                .as("Trace ID should be propagated from parent span")
                .isEqualTo(parentTraceId);
            
            // Verify the payment was processed successfully
            assertThat(response.getPaymentId())
                .as("Payment should be processed with trace context")
                .isNotNull();
            
            // In a full implementation with actual service calls, we would verify:
            // 1. All gRPC calls to tokenization, fraud detection, 3DS, and PSP
            //    include the same trace ID in their metadata
            // 2. All spans created during processing are children of the parent span
            // 3. The trace ID is included in all log entries
            
        } finally {
            parentSpan.end();
        }
    }
    
    @Property(tries = 50)
    void eachRequestGetsUniqueTraceId(
            @ForAll @NumericChars @StringLength(value = 16) String cardNumber1,
            @ForAll @NumericChars @StringLength(value = 16) String cardNumber2,
            @ForAll @IntRange(min = 1, max = 12) int expiryMonth,
            @ForAll @IntRange(min = 2025, max = 2035) int expiryYear,
            @ForAll @NumericChars @StringLength(value = 3) String cvv,
            @ForAll @BigRange(min = "0.01", max = "10000.00") BigDecimal amount) {
        
        Assume.that(!cardNumber1.equals(cardNumber2));
        
        // Process first payment
        Span span1 = tracer.spanBuilder("request-1").startSpan();
        String traceId1;
        try (var scope = span1.makeCurrent()) {
            traceId1 = span1.getSpanContext().getTraceId();
            PaymentRequest request1 = new PaymentRequest(
                cardNumber1, expiryMonth, expiryYear, cvv, amount, "USD"
            );
            paymentService.processPayment(request1, UUID.randomUUID());
        } finally {
            span1.end();
        }
        
        // Process second payment
        Span span2 = tracer.spanBuilder("request-2").startSpan();
        String traceId2;
        try (var scope = span2.makeCurrent()) {
            traceId2 = span2.getSpanContext().getTraceId();
            PaymentRequest request2 = new PaymentRequest(
                cardNumber2, expiryMonth, expiryYear, cvv, amount, "USD"
            );
            paymentService.processPayment(request2, UUID.randomUUID());
        } finally {
            span2.end();
        }
        
        // Different requests should have different trace IDs
        assertThat(traceId1)
            .as("Each request should have a unique trace ID")
            .isNotEqualTo(traceId2);
    }
}
